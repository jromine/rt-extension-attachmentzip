<%once>
# MASON Handler for path /Ticket/AttachmentZip/ [All|Current|PDF] / TicketID / File.ext
# # vim: set filetype=mason :
#
# https://masonbook.houseabsolute.com/book/chapter-3.html
# MASON Special Globals
#
# $m - A HTML::Mason::Request object: retrieve information on the current
# request, call other components, or affect the flow of execution.
# https://masonbook.houseabsolute.com/book/chapter-4.html
#
# $r - an Apache::Request object.

use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
use PDF::API2;
use File::Temp qw( tempfile tempdir );
use Data::Dumper;
use Date::Parse;

# MIME type conversions handled by LibreOffice (soffice)
#
my %soffice_types = (
#  'application/pdf'                                                            => '.pdf',
#  'text/html'                                                                  => '.html',
  'text/plain'                                                                 => '.txt',

  'application/vnd.openxmlformats-officedocument.wordprocessingml.document'    => '.docx',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'          => '.xlsx',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation'  => '.pptx',
  'application/msword'                                                         => '.doc',
  'application/vnd.ms-excel'                                                   => '.xls',
  'application/vnd.ms-powerpoint'                                              => '.ppt',
  'application/rtf'                                                            => '.rtf',

  'application/vnd.oasis.opendocument.chart'                                   => '.odc',
  'application/vnd.oasis.opendocument.database'                                => '.odb',
  'application/vnd.oasis.opendocument.formula'                                 => '.odf',
  'application/vnd.oasis.opendocument.graphics'                                => '.odg',
  'application/vnd.oasis.opendocument.graphics-template'                       => '.otg',
  'application/vnd.oasis.opendocument.image'                                   => '.odi',
  'application/vnd.oasis.opendocument.presentation'                            => '.odp',
  'application/vnd.oasis.opendocument.presentation-template'                   => '.otp',
  'application/vnd.oasis.opendocument.spreadsheet'                             => '.ods',
  'application/vnd.oasis.opendocument.spreadsheet-template'                    => '.ots',
  'application/vnd.oasis.opendocument.text'                                    => '.odt',
  'application/vnd.oasis.opendocument.text-master'                             => '.odm',
  'application/vnd.oasis.opendocument.text-template'                           => '.ott',
  'application/vnd.oasis.opendocument.text-web'                                => '.oth',

  'application/vnd.visio'                                                      => '.vsd',
  'application/x-abiword'                                                      => '.abw',
  'image/bmp'                                                                  => '.bmp',
  'image/gif'                                                                  => '.gif',
#  'image/vnd.microsoft.icon'                                                   => '.ico',
  'image/jpeg'                                                                 => '.jpg',
  'image/jpg'                                                                  => '.jpg',
  'image/png'                                                                  => '.png',
#  'image/svg+xml'                                                              => '.svg',
  'image/tiff'                                                                 => '.tiff',
#  'image/webp'                                                                 => '.webp'
);
</%once>
<%init>
#  grab ticket number from URL
my ($mode, $id) = ($m->dhandler_arg =~ m/^((?:all|current|pdf))\/(\d+)\//i );

unless ($mode && $id) {
  return $m->abort( 404 );
}

# load ticket object
my $Ticket = LoadTicket($id);

unless ($Ticket->id and $Ticket->CurrentUserHasRight('ShowTicket')) {
  Abort("No permission to view ticket");
}

# Get attachments
my $Attachments = $Ticket->Attachments;

# Remember, each message in a transaction is an attachment; we only
# want named attachments (real files)
$Attachments->LimitHasFilename;

# Only want PDF
#if ($mode =~ m/pdf/i) {
#  $Attachments->ContentType (VALUE => 'application/pdf');
#}

# attach oldest first, use newest revision
$Attachments->OrderByCols(
    { FIELD => 'Created', ORDER => 'ASC' },
    { FIELD => 'id',      ORDER => 'ASC' },
);

# collect individual attached files in a hash of arrays
my %documents;
my @filenames; # ordered list
while ( my $attach = $Attachments->Next() ) {
  
   next unless ($attach->Filename());

   my $k = $attach->Filename || $attach->id;

   push @filenames, $k unless $documents{ $k };
   unshift( @{ $documents{ $k } }, $attach );
}

my $tempdir = File::Temp->newdir( CLEANUP => 1 );
my $zip = Archive::Zip->new();
my ($zip_fh,$zip_name) = Archive::Zip::tempFile($tempdir);

# make sure we can find wkhtmltopdf and others
my $path = $ENV{'PATH'};
$ENV{'PATH'} =  '/usr/local/bin:'.$path unless ($path =~ m|/usr/local/bin|);

# filter content with converter
# @param String content
# @returns String content
#
my $html_convert = sub {

  my $content = shift;
  my $content_type = shift;

  # maybe this should decode into utf8, and Correspond.html should
  # be served as utf8, but it works like this so leave it.

  my $ext = '.html';

  my ($ih, $infile) = tempfile( DIR => $tempdir, SUFFIX => $ext);
  binmode $ih;
  print $ih $content;

  my $outfile = $infile;
  $outfile =~ s/$ext/.pdf/;

  $RT::Logger->info( "wkhtmltopdf -q --no-images --disable-javascript --page-size letter $infile $outfile");
  system("wkhtmltopdf -q --no-images --disable-javascript --page-size letter $infile $outfile");

  open my $fh, '<', $outfile or die "Can't open file $!";
  binmode $fh;
  read $fh, my $s, -s $fh;
  close $fh;

  close $ih; # and unlink
  unlink $outfile;

  return $s;

};

my $qpdf_convert = sub {

  my $content = shift;
  my $ext = '.bak';

  my ($ih, $infile) = tempfile( DIR => $tempdir, SUFFIX => $ext);
  binmode $ih;
  print $ih $content;

  my $outfile = $infile;
  $outfile =~ s/$ext/.pdf/;

  $RT::Logger->info( "qpdf --force-version=1.4 --decrypt $infile $outfile" );

  system("qpdf --force-version=1.4 --decrypt $infile $outfile");

  open my $fh, '<', $outfile or die "Can't open file $!";
  binmode $fh;
  read $fh, my $s, -s $fh;
  close $fh;

  close $ih; # and unlink
  unlink $outfile;

  return $s;

};

my $soffice_convert = sub {

  my $content = shift;
  my $type = shift;
  my $ext =  $soffice_types{$type};

  my ($ih, $infile) = tempfile( DIR => $tempdir, SUFFIX => $ext);
  binmode $ih;
  print $ih $content;

  my $outfile = $infile;
  $outfile =~ s/$ext/.pdf/;

  $RT::Logger->info("libreoffice --headless --convert-to pdf --outdir $tempdir $infile (outfile=$outfile)");

  system("libreoffice --headless --convert-to pdf --outdir $tempdir $infile");

  open my $fh, '<', $outfile or die "Can't open file $!";
  binmode $fh;
  read $fh, my $s, -s $fh;
  close $fh;

  close $ih; # and unlink infile
  unlink $outfile;

  return $s;

};
</%init>
<%perl>
if ($mode =~ m/pdf/i) {
}
else { # zip format

  foreach my $name (keys %documents) {
    foreach my $revision (@{$documents{$name}}) {
      # temporary on-disk storage of files for zip
      my $tempfile_fh = File::Temp->new(DIR => $tempdir, SUFFIX => ".tmp");

      # these objects go out of scope before the zipfile is written to disk,
      # which would cause them to be deleted too early.  Let the tempdir
      # CLEANUP take care of them instead.
      $tempfile_fh->unlink_on_destroy(0);
      my $tempfile_name = $tempfile_fh->filename;
      print $tempfile_fh $revision->Content;

      # need to close the FH so that perl flushes output
      close $tempfile_fh;

      # add tempfile to zip as the original name from the attachment, with revision ID
      my $member;
      if ($mode =~ m/all/i) {
        $member = $zip->addFile($tempfile_name,sprintf('ticket_%d/%d_%s',$Ticket->Id,$revision->Id,$revision->Filename));
      } else {
        $member = $zip->addFile($tempfile_name,sprintf('ticket_%d/%s',$Ticket->Id,$revision->Filename));
      }
      $member->desiredCompressionMethod( COMPRESSION_DEFLATED );
      last if ($mode !~ m/all/i);
    }
  }

  if ( $zip->writeToFileHandle($zip_fh) == AZ_OK) {
    # need to close the FH so that perl flushes output
    close $zip_fh;
    $r->content_type( "application/zip" );
    $m->clear_buffer();
    $m->out($m->file($zip_name));
    $m->abort;
  } else {
    close $zip_fh;
    $RT::Logger->error("write error writing zip to $zip_name");
    $r->content_type( "text/plain" );
    $m->clear_buffer();
    $m->out("Sorry, error creating zip.  Please contact your system administrator.");
    $m->abort;
  }
}
undef $tempdir;
</%perl>
<%attr>
AutoFlush => 0
</%attr>
